# 代理模式

**代理模式**是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。

代理模式限制了对原有真实对象的访问，保护了原有真实对象不去暴露一些不该暴露的东西，往往可以用于封装接口。



![image-20220305003415320](C:\Users\seara\AppData\Roaming\Typora\typora-user-images\image-20220305003415320.png)

代理模式建议新建一个与原服务对象接口相同的代理类， 然后更新应用以将代理对象传递给所有原始对象客户端。 代理类接收到客户端请求后会创建实际的服务对象， 并将所有工作委派给它。

代理将自己伪装成数据库对象， 可在客户端或实际数据库对象不知情的情况下处理延迟初始化和缓存查询结果的工作。

这有什么好处呢？ 如果需要在类的主要业务逻辑前后执行一些工作， 你无需修改类就能完成这项工作。 由于代理实现的接口与原类相同， 因此你可将其传递给任何一个使用实际服务对象的客户端。

## 代理模式模板

![plroxy](..\pictures\proxy.png)

![image-20220305003744043](D:\code\DesignPattern\pictures\tv_example.png)

程序库提供了视频下载类。 但是该类的效率非常低。 如果客户端程序多次请求同一视频， 程序库会反复下载该视频， 而不会将首次下载的文件缓存下来复用。

代理类实现和原下载器相同的接口， 并将所有工作委派给原下载器。 不过， 代理类会保存所有的文件下载记录， 如果程序多次请求同一文件， 它会返回缓存的文件。

## 代理模式分类

1. 远程代理，一个对象在不同地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。（WebService）
2. 虚拟代理，根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。如HTML的图片，那些未打开的图片框通过代理替代了真实图片
3. 安全代理，来控制真实对象访问权限。一般用于对象应该有不腰痛的访问权限的时候。
4. 智能指引，调用真实对象时，代理处理另外一些事情。（如智能指针的使用，计算真实对象引用次数，当没人用的时候释放，或者第一次引用一个对象时，将他装入内存，或者在实际使用一个对象，检查是否锁定他，保证不能被其他对象改变。）

## 代理模式实现方式

1. 如果没有现成的服务接口， 你就需要创建一个接口来实现代理和服务对象的可交换性。 从服务类中抽取接口并非总是可行的， 因为你需要对服务的所有客户端进行修改， 让它们使用接口。 备选计划是将代理作为服务类的子类， 这样代理就能继承服务的所有接口了。
2. 创建代理类， 其中必须包含一个存储指向服务的引用的成员变量。 通常情况下， 代理负责创建服务并对其整个生命周期进行管理。 在一些特殊情况下， 客户端会通过构造函数将服务传递给代理。
3. 根据需求实现代理方法。 在大部分情况下， 代理在完成一些任务后应将工作委派给服务对象。
4. 可以考虑新建一个构建方法来判断客户端可获取的是代理还是实际服务。 你可以在代理类中创建一个简单的静态方法， 也可以创建一个完整的工厂方法。
5. 可以考虑为服务对象实现延迟初始化。

## 代理模式优缺点

| 优点                                                         | 缺点                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1.你可以在客户端毫无察觉的情况下控制服务对象。<br />2. 如果客户端对服务对象的生命周期没有特殊要求， 你可以对生命周期进行管理。<br />3.即使服务对象还未准备好或不存在， 代理也可以正常工作。<br />4.*开闭原则*。 你可以在不对服务或客户端做出修改的情况下创建新代理。 | 1.代码可能会变得复杂， 因为需要新建许多类。<br />2.服务响应可能会延迟。 |

## 与其他模式的关系

- [适配器模式](https://refactoringguru.cn/design-patterns/adapter)能为被封装对象提供不同的接口， [代理模式](https://refactoringguru.cn/design-patterns/proxy)能为对象提供相同的接口， [装饰模式](https://refactoringguru.cn/design-patterns/decorator)则能为对象提供加强的接口。
- [外观模式](https://refactoringguru.cn/design-patterns/facade)与[代理](https://refactoringguru.cn/design-patterns/proxy)的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 *代理*与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与*外观*不同。
- [装饰](https://refactoringguru.cn/design-patterns/decorator)和[代理](https://refactoringguru.cn/design-patterns/proxy)有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于*代理*通常自行管理其服务对象的生命周期， 而*装饰*的生成则总是由客户端进行控制。